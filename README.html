<!DOCTYPE html><html><head><meta charset="utf-8"><style>@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

* {
    box-sizing: border-box;
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
}

body .markdown-body {
    padding: 45px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body strong {
  font-weight: bold;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
  color: #4078c0;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
  display: table;
  content: "";
}

.markdown-body hr:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
  opacity: 0;
}

.markdown-body .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.markdown-body .octicon-link:before {
  content: '\f05c';
}

.markdown-body:before {
  display: table;
  content: "";
}

.markdown-body:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
  line-height: 1;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 .anchor {
  line-height: 1;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h3 .anchor {
  line-height: 1.2;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h4 .anchor {
  line-height: 1.2;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h5 .anchor {
  line-height: 1.1;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body h6 .anchor {
  line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
  color: #969896;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #333;
}

.markdown-body .pl-ent {
  color: #63a35c;
}

.markdown-body .pl-k {
  color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #183691;
}

.markdown-body .pl-v {
  color: #ed6a43;
}

.markdown-body .pl-id {
  color: #b52a1d;
}

.markdown-body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

.markdown-body .pl-ml {
  color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

.markdown-body .pl-mq {
  color: #008080;
}

.markdown-body .pl-mi {
  color: #333;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #333;
  font-weight: bold;
}

.markdown-body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

.markdown-body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

.markdown-body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

.markdown-body .pl-mo {
  color: #1d3e81;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
  color: #767676;
  font-weight: normal;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body .plan-choice {
  padding: 15px;
  padding-left: 40px;
  display: block;
  border: 1px solid #e0e0e0;
  position: relative;
  font-weight: normal;
  background-color: #fafafa;
}

.markdown-body .plan-choice.open {
  background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
  display: block;
}

.markdown-body .plan-choice-free {
  border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
  border-radius: 0 0 3px 3px;
  border-top: 0;
  margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
  position: absolute;
  left: 15px;
  top: 18px;
}

.markdown-body .plan-choice-exp {
  color: #999;
  font-size: 12px;
  margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
  margin-top: 10px;
  display: none;
}

.markdown-body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}
</style><title>README</title></head><body><article class="markdown-body"><h1>
<a id="user-content-projet-rp" class="anchor" href="#projet-rp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Projet-RP</h1>
<p>Réseaux et Protocoles - Projet de L3 : Table de hachage distribuée</p>
<h2>
<a id="user-content-compiler-tester" class="anchor" href="#compiler-tester" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Compiler, tester</h2>
<p>Notre programme a plusieurs niveaux de debug. Le niveau de debug se définit à la compilation, avec le flag <code>-DDEBUG_LEVEL=N</code> (ou <code>make debug</code>/<code>make warnings</code>/<code>DEBUG_FLAG=-DDEBUG_LEVEL=N</code>)
Ce niveau définit la verbosité du programme. Zero pour silencieux, un pour les warnings, deux pour verbeux.</p>
<p>Note: Changer le niveau de debug nécessite un appel à make clean.</p>
<p>Ce niveau de debug peut être écrasé par la variable environnement DEBUG_RESEAU qui prend précédence sur le flag de compilation.</p>
<ul>
<li>
<code>make all</code> Compile client &amp; serveur en mode silencieux</li>
<li>
<code>make server</code> Compile seulement le serveur en mode silencieux</li>
<li>
<code>make client</code> Compile seulement le client en mode silencieux</li>
<li>
<code>make debug</code> Compile en mode debug (999)</li>
<li>
<code>make warnings</code> Compile en mode warnings (debug=1)</li>
</ul>
<p>Le mode debug est ultra stylé, il est donc recommandé de toujours compiler en mode debug.</p>
<h2>
<a id="user-content-fichier-de-test" class="anchor" href="#fichier-de-test" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fichier de test</h2>
<p>Nous avons inclus un fichier de test <code>test.sh</code> dans le rendu pour vérifier que tout fonctionne aussi bien chez vous que chez nous.</p>
<p>Normalement, en mode debug, aucun warning/erreur ne devrait apparaître en exécutant ce fichier (à l'exception du SIGKILL à la fin).</p>
<h2>
<a id="user-content-questions-traitées" class="anchor" href="#questions-trait%C3%A9es" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Questions traitées</h2>
<h3>
<a id="user-content-11-premiers-pas" class="anchor" href="#11-premiers-pas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.1 Premiers pas</h3>
<p>La DHT est en place et le client/serveur sont codés et communiquent entre eux sans problèmes et ce même sur des réseaux distants (modulo les pertes de paquet dans ce cas là).</p>
<ul>
<li>GET renvoie toutes les IPs possibles au client lorsqu'il demande un hash</li>
<li>PUT met le tuple (hash,ip) adjoint à un timestamp dans la DHT</li>
</ul>
<p>La DHT est un tableau continu. Cf commentaires doxygen de serveur.c</p>
<h3>
<a id="user-content-12-connexion-et-déconnexion-entre-deux-serveurs" class="anchor" href="#12-connexion-et-d%C3%A9connexion-entre-deux-serveurs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.2 Connexion et déconnexion entre deux serveurs</h3>
<p>Une tentative a été faite pour implémenter le multicast qui aurait permis
aux serveurs de se découvrir entre eux. Malheureusement nous n'avons pas réussi
à implémenter ceci.
La documentation pour l'IPV6 multicast en C et sur linux est quasi inexistante.</p>
<p>J'ai donc toute l'architecture qui est faite (et qui marche), mais les serveurs
n'arrivent pas à se trouver entre eux.</p>
<p>Vous pouvez tester les commandes <code>plzgibhashes</code> et <code>kktakethis [hash] [ip] [timestamp]</code> avec <code>nc -u [host] [port]</code></p>
<p>Exemple:</p>
<pre><code>printf "plzgibhashes" | nc -q1 -u 'localhost' '9090'
printf "kktakethis $hash2 client_3 $(date +%s)" | nc -q1 -u 'localhost' '9090'
</code></pre>
<h3>
<a id="user-content-13-keep-alive-entre-serveurs" class="anchor" href="#13-keep-alive-entre-serveurs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.3 Keep alive entre serveurs</h3>
<p>Impossible de le traiter sans le multicast</p>
<h3>
<a id="user-content-14-obsolescence" class="anchor" href="#14-obsolescence" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.4 Obsolescence</h3>
<p>La fonction dht_get ne renverra jamais un hash ayant expiré. Le temps par défaut
est de 30 secondes, définissable à la compilation avec
<code>-DHASH_DEPRECATION_TIME=</code>
Un garbage collector a été mis en place pour gérer les hashs périmés. Celui-ci
s'execute toutes les <code>GARBAGE_COL_TIME</code> secondes; temps configurable à la
compilation avec <code>-DGARBAGE_COL_TIME=</code></p>
<h3>
<a id="user-content-15-dht-à-plus-de-2-serveurs" class="anchor" href="#15-dht-%C3%A0-plus-de-2-serveurs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.5 DHT à plus de 2 serveurs</h3>
<p>Cette partie fonctionne si le multicast fonctionne également.</p>
<h3>
<a id="user-content-16-pistes-damélioration" class="anchor" href="#16-pistes-dam%C3%A9lioration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.6 Pistes d'amélioration</h3>
<h4>
<a id="user-content-161-rendre-le-garbage-collector-moins-bloquant" class="anchor" href="#161-rendre-le-garbage-collector-moins-bloquant" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.6.1 Rendre le garbage collector moins bloquant</h4>
<p>J'aurais pu rendre le GC moins bloquant en empêchant seulement d'accéder aux hash situés après les zones où le GC est déjà passé.</p>
<p>Nous l'implémenterions avec une pthread_cond permettant de vérifier atomiquement
si le garbage collector est passé sur la zone à laquelle on souhaite accéder,
avant d'y accéder.</p>
<div class="highlight highlight-source-c"><pre><span class="pl-c"><span class="pl-c">//</span> Si conflit avec le garbage collector</span>
<span class="pl-k">while</span> (d-&gt;gc_hash == i){
	<span class="pl-c"><span class="pl-c">//</span> Attente d'un signal du garbage collector</span>
	<span class="pl-c1">pthread_cond_wait</span>(&amp;d-&gt;cond, &amp;d-&gt;mutex);
}</pre></div>
<h4>
<a id="user-content-162-un-thread-par-commande-traitée" class="anchor" href="#162-un-thread-par-commande-trait%C3%A9e" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.6.2 Un thread par commande traitée</h4>
<p>Le traitement des commandes (<code>treat_cmd()</code>) est extrêmement facile à
multithreader. Cependant, actuellement tous les accès à la DHT se font en
section critique, ce qui rendrait un multi threading inutile.</p>
<p>Il aurait fallu une mutex par hash.</p>
<ul>
<li>dht_get et dht_put vérifient toujours tous les deux qu'ils passent après le
passage du garbage collector</li>
</ul>
<p>Arbre d'exécution:</p>
<ul>
<li>dht_put crée le hash
<ul>
<li>Allocation (A),</li>
<li>mutex_init (B),</li>
<li>mutex_lock (C)</li>
<li>Remplissage du hash (D)</li>
<li>mutex_unlock (E)</li>
</ul>
</li>
</ul>
<p>Simultanément, dht_get commence par cette opération</p>
<pre><code>if (hash != NULL)
   pthread_mutex_lock(mutex);
</code></pre>
<p>Voici un arbre d'exécution pour prouver que ça ne posera aucun soucis,
A,B,C,D,E les états possibles de dht_put.</p>
<ul>
<li>Soit A, B, C
<ul>
<li>Le hash n'existe pas, dht_get renvoie NULL</li>
</ul>
</li>
<li>Soit D
<ul>
<li>Le hash existe ou n'existe pas.
<ul>
<li>Si elle existe, la mutex est verrouillée. Je renverrai &amp;IP.</li>
<li>Sinon, la mutex existe mais je ne suis pas au courant. Je renvoie NULL.</li>
</ul>
</li>
</ul>
</li>
<li>Soit E
<ul>
<li>Je renvoie &amp;IP.</li>
</ul>
</li>
</ul>
<h4>
<a id="user-content-163-envoyer-un-ack-pour-dht_put" class="anchor" href="#163-envoyer-un-ack-pour-dht_put" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.6.3 Envoyer un ACK pour dht_put</h4>
<p>Pour le moment le client ne sait pas si son hash a bien été envoyé ou
non. Il peut éventuellement vérifier lui-même en faisant un GET.</p>
<h4>
<a id="user-content-164-numéroter-les-requêtes" class="anchor" href="#164-num%C3%A9roter-les-requ%C3%AAtes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.6.4 Numéroter les requêtes</h4>
<p>J'aurais aimé pouvoir être certain que mes GET et mes PUT arrivent dans l'ordre.
Si j'étais utilisateur de mon programme, j'aurais voulu avoir cette feature.</p>
<h4>
<a id="user-content-164-bis-un-checksum-" class="anchor" href="#164-bis-un-checksum-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.6.4 bis Un checksum ?</h4>
<p>Il y a peu d'intérêt à implémenter un traitement anti corruption de données mais
la feature pourrait être pratique.</p>
<p>Si la commande se corrompt, ce n'est pas si grave, le serveur ne renvoie rien et le client reessaiera.</p>
<p>Si un PUT se corrompt sur le hash ou l'IP, le hash ne sera jamais demandé, ou
il pointera sur la mauvaise personne pendant 30s car il ne sera jamais
réactualisé. Comme GET renvoie toutes les IPs possibles d'un hash le problème
est mineur.</p>
<p>Si un GET se corrompt, le serveur renvoit qu'aucune IP ne possède ce hash pour le moment, et le client retentera plus tard.</p>
<p>Si une réponse au GET se corrompt, le client verra bien que l'IP est mauvaise et il redemandera le hash.</p>
</article></body></html>